// 最后一个栈
// var nJk = (kk.UN(GS, Sb))[kk.h5(Cz, bS)](ZF, kk.ON(d3, RT));

// kk.UN(GS, Sb) = '{"sensor_data":"'
// kk.h5(Cz, bS) = 'concat'
//ZF = '2;0;4539955;3748161;12,0,0,0,3,0;^@M@iMEo;KR7ciWuwEFgRbH*M;FHAX?.;(C9=~!X$Px)|uhE5UF}}9fb:|/E+UfK]jlb^`ZBv)K0h|w1:k,a^1P:!d*<sVcUfSz| &*nWhB|Xvq3e&2v~PQpO8ero?JG^b445Tl)|=hXLE^+J}RYqHP(#wv_h};3Ue/4QZjF@e/1v.5z-k9{Dl/F;Kb||rno;Lx(^`_hu#WM;d|Y !5h5n#KGKpDG$/2VB`zBS|fgNe[Doz+F:O0Zl)BCL|IRJu-:neV&Gbbl6nnoKbGxnO1sQr;DA&hHdF8s1v+i!KJT,cqv_nmE-#r;#V&-H$Sqt7It63lWQ},=zuv{J{eFT(%mf#ss eQBfXR8aL _/Z]6Y<UlF{bQ`.GHzD |aH0BU+S8pX2I{N^K2z4T4h]KS>>ubK!R;GCX~l2H<Av]}%:e]Da+fBF2dl*g|Yh.PC4_vS !JM2~I<FumdJV:%4zN4:?6wi?h_q,8}ZN3:! 7Axy|#;!3FXPfn%1~!16ddj2e@&}p#B_c*Qwx,R/-]~>2AX]%MgKeq G7fGD:)>StpFh;$S7:j:`Wd18L=>$=i2?|rXb[j`]HO~OdtQ57~w4J[:c%!j^fLl;qdYvtd#Irx[zD!=&+ j^z?tmHlE+s*G)eiVd}<2`B5pPyAdd;oET.E}=UzsOJpbnoMLfa|vHE]9~<c4<u[c~aHv)cp)ve7I6z4.Kgu.@G]2Bw~pko<*!f4oKoj+#z8fm<`$ Asi@bXS@eS5%Ba;PDpNpVtz)FM+!m!&XtH] .N88jGA3`{]0jD&P4OzsxN,4.)RH0p)p|6I1YIG<)3jF1sP598gdpOz*{Rm5w@Z<Ld%sB,<$qawOC yUIw#H#;wt)JhFR^?Pm>9C*!j5)0}^Z>5ok6v*21_mtDJF2V/wsa*tXSewN.uRoH:8,LJNVM+QY4N3qZ1k?q/63!*H,leJVDK05mC#&kDIfJk#fT%8Cw9_BQhq[D*:`%I*.$Vepoi)HHd]! efqVj5 7wl`@m1Xg`UQ@cJxzv3]MVb+0|mL>KJvW=d!3&3I,gt`KAkKA;l0t]]#NX-rSxDY]%p[2PLni&58!.`3S<jB-p0adT`&5($6D*]bIUd;.ST}z_Qz4?d=-rv%)!zqr0p*$]9E(!uDdy:{RJNjtHWF?$6%6QRI>[O@ygLm_q:GM~Lc|UK?NN<B-HEnLJ_9eYo,D0=)^G9@`qd},7Q{l#?Wi$3]/C+S/clF+BpG&{D*HBT63 J[apYNJ8R)ArJq-!*leqgg?)L]>.X%SDv Lcku%eJ/U5W4l5;UK!~/Y(;zgldaC;[nst3xm?AOSt A:xHq*6n@R>-]Fcpk!,[|_0:rEP=}#?[y+a+ZYgBH*un77>yC/gfI4He8*Mjs&1$=aW`M@K8]7_8{axJ9)Cxgd wjIP1_|3?J~+9^%d,h:&c(hSM>?2$MPv>4aWt8s  {<|2!NoH9>20+LKh@rL.)lX&0$t9r`U)`m./9c,SBBp|V,{G^>P:n?T//>?;c:F;DFhoab#whrDo7,:&ic48x<m`J)45z]NKh[n55+NeU@?9FFYFk4{Hrq%6B2ifP< |P;f2 %Xr%TRTqs-{1%X<(ek&ZOb$.f[S(xJspsItfkqr=;IFVB<qJ5`TLslXN[q}$OoW[;;n02Srt=4u(soC/ToT*1Sr%Y>*]ioUH<#/F&$x?Aq)9E6hGZvI%,ufyK%? %L9DY;~)1OW0Cj6M@K3m!=-VRbgk=%44*nFk~e]U^+?u*bsCRXV5@`L18)CS_(4$MDDGra:$2Mq6aj;uj2!uK5,>]Vj!Q>0A_fP!1#-;GoJa&guC`sMh=|{exu;Vf~fg-rfbD9+L[8V>O<K`f%,,L>wZ$%Hb@Mtx321`$&+YUJ3W;vFGAd[f#o7`!5brEa9@mfl?sr%RjP$v?*[?_,=DyRTTs-_zfvSk(74fmbR%U6nbL.{]qU%gN89R]wOwZzl!Bm]0#);l7)V]B;}X8l}L Haw.[aeS#[!o430ICiCh^:B/~r$,k-Q426.t<vG<cN$@b6RQ_+mH>#|vneW,},E=;Dy6UF-nC7n-Z7W+Dv}_KH:~];3tb(E9@Ynm~dVSjzn}GlXO}Kuk8bJ>(my]Fo3*5QsY0/apP:oa$6Umg;!r$}%:H9k8{]#&FZsV<(y#9GQ2T!.)S(yp %7:bcds[y]gb3bR95*2#=iG$Q[c={g~{mELk!*opZk4ZlC<g6>-()uv+|K/sKKc[f,IO|K%5nNUmEqyZ{qlyFwzF#4T6|w 8F|8Ui8*9'

// kk.ON(d3, RT) = '"}'

// 所以 nJk = '{"sensor_data":"' + ZF的值 + '"}'，核心是 ZF的值

// 栈列表
// IKK         var nJk = (kk.UN(GS, Sb))[kk.h5(Cz, bS)](ZF, kk.ON(d3, RT));
// Fc          var Fc = function(Kkk)
// jtk         Jg(function jtk() {
// fMk         var fMk = function(tPk) {   有结果堆栈
// Xxk         fMk(fMk[kk.Ij(RT, AEk)] = mQ);   无结果堆栈

// var QJk = YZ(vkk);    vkk = "_abck"    _abck生成
// tv = sF(Mw, [Vv, jg, Jg(Jg(Uv))])     tv生成
// ZF = Vv[kk.Y8.call(null, Lh, ZK)](tv)     ZF加密字符串生成，确定Vv是长度58的数组，其中kk.Y8.call(null, Lh, ZK) = "join"
// ZF = XQ(XQ(XQ(XQ(jg, tv), jg), tv), ZF = XQ(XQ(XQ(XQ(XQ(Pb, hb), tv), OQ(kk[kk.FU.apply(null, [Tb, Sb])](), Sg(kw, [nK, QQ, ZF]))), tv), ZF));

// 经过多次测试 以下是 chrome 浏览器不同日期/不同请求链接/原页面刷新等条件下测试结果
// 不变的参数序列： [0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57]
// 变化的参数序列： [1, 25, 27, 53]
